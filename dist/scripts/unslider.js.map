{"version":3,"sources":["../assets/scripts/unslider.js"],"names":["factory","module","exports","require","define","amd","window","jQuery","$","Unslider","context","options","self","this","_","defaults","autoplay","delay","speed","easing","keys","prev","next","nav","arrows","animation","selectors","container","slides","animateHeight","activeClass","swipe","swipeThreshold","$context","$parent","$container","$slides","$nav","$arrows","total","current","prefix","eventSuffix","Math","random","interval","init","extend","find","addClass","children","setup","each","index","_ucfirst","event","special","initSwipe","start","calculateSlides","trigger","animate","wrap","parent","position","css","length","prop","setTimeout","stop","clearTimeout","initNav","key","label","getAttribute","isFunction","call","eq","append","insertAfter","on","$me","siblings","removeClass","attr","initArrows","val","push","initKeys","document","e","which","width","movestart","distX","distY","preventDefault","move","moveend","abs","left","initInfinite","pos","item","apply","filter","clone","destroyArrows","i","$arrow","remove","destroySwipe","off","destroyKeys","setIndex","to","min","max","_active","dir","isNaN","fn","target","animateHorizontal","infinite","slide","animateVertical","outerHeight","dummy","obj","_move","animateFade","$active","opacity","height","$el","callback","className","str","toLowerCase","replace","match","toUpperCase","velocity","arguments","unslider","opts","$this","data","split","console","warn"],"mappings":"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","file":"unslider.js","sourcesContent":["/**\n *   Unslider\n *   version 2.0\n *   by @idiot and friends\n */\n\n(function(factory) {\n\tif (typeof module === 'object' && typeof module.exports === 'object') {\n\t\tfactory(require('jquery'));\n\t} else if (typeof define === 'function' && define.amd) {\n\t    // AMD. Register as an anonymous module.\n        define([], factory(window.jQuery));\n    } else {\n\t\tfactory(window.jQuery);\n\t}\n}(function($) {\n\t//  Don't throw any errors when jQuery\n\tif(!$) {\n\t\treturn console.warn('Unslider needs jQuery');\n\t}\n\n\t$.Unslider = function(context, options) {\n\t\tvar self = this;\n\n\t\t//  Create an Unslider reference we can use everywhere\n\t\tself._ = 'unslider';\n\n\t\t//  Store our default options in here\n\t\t//  Everything will be overwritten by the jQuery plugin though\n\t\tself.defaults = {\n\t\t\t//  Should the slider move on its own or only when\n\t\t\t//  you interact with the nav/arrows?\n\t\t\t//  Only accepts boolean true/false.\n\t\t\tautoplay: false,\n\n\t\t\t//  3 second delay between slides moving, pass\n\t\t\t//  as a number in milliseconds.\n\t\t\tdelay: 3000,\n\n\t\t\t//  Animation speed in millseconds\n\t\t\tspeed: 750,\n\n\t\t\t//  An easing string to use. If you're using Velocity, use a\n\t\t\t//  Velocity string otherwise you can use jQuery/jQ UI options.\n\t\t\teasing: 'swing', // [.42, 0, .58, 1],\n\n\t\t\t//  Does it support keyboard arrows?\n\t\t\t//  Can pass either true or false -\n\t\t\t//  or an object with the keycodes, like so:\n\t\t\t//  {\n\t\t\t//\t prev: 37,\n\t\t\t//\t next: 39\n\t\t\t// }\n\t\t\t//  You can call any internal method name\n\t\t\t//  before the keycode and it'll be called.\n\t\t\tkeys: {\n\t\t\t\tprev: 37,\n\t\t\t\tnext: 39\n\t\t\t},\n\n\t\t\t//  Do you want to generate clickable navigation\n\t\t\t//  to skip to each slide? Accepts boolean true/false or\n\t\t\t//  a callback function per item to generate.\n\t\t\tnav: true,\n\n\t\t\t//  Should there be left/right arrows to go back/forth?\n\t\t\t//   -> This isn't keyboard support.\n\t\t\t//  Either set true/false, or an object with the HTML\n\t\t\t//  elements for each arrow like below:\n\t\t\tarrows: {\n\t\t\t\tprev: '<a class=\"' + self._ + '-arrow prev\">Prev</a>',\n\t\t\t\tnext: '<a class=\"' + self._ + '-arrow next\">Next</a>'\n\t\t\t},\n\n\t\t\t//  How should Unslider animate?\n\t\t\t//  It can do one of the following types:\n\t\t\t//  \"fade\": each slide fades in to each other\n\t\t\t//  \"horizontal\": each slide moves from left to right\n\t\t\t//  \"vertical\": each slide moves from top to bottom\n\t\t\tanimation: 'horizontal',\n\n\t\t\t//  If you don't want to use a list to display your slides,\n\t\t\t//  you can change it here. Not recommended and you'll need\n\t\t\t//  to adjust the CSS accordingly.\n\t\t\tselectors: {\n\t\t\t\tcontainer: 'ul:first',\n\t\t\t\tslides: 'li'\n\t\t\t},\n\n\t\t\t//  Do you want to animate the heights of each slide as\n\t\t\t//  it moves\n\t\t\tanimateHeight: false,\n\n\t\t\t//  Active class for the nav\n\t\t\tactiveClass: self._ + '-active',\n\n\t\t\t//  Have swipe support?\n\t\t\t//  You can set this here with a boolean and always use\n\t\t\t//  initSwipe/destroySwipe later on.\n\t\t\tswipe: true,\n\t\t\t// Swipe threshold -\n\t\t\t// lower float for enabling short swipe\n\t\t\tswipeThreshold: 0.2\n\t\t};\n\n\t\t//  Set defaults\n\t\tself.$context = context;\n\t\tself.options = {};\n\n\t\t//  Leave our elements blank for now\n\t\t//  Since they get changed by the options, we'll need to\n\t\t//  set them in the init method.\n\t\tself.$parent = null;\n\t\tself.$container = null;\n\t\tself.$slides = null;\n\t\tself.$nav = null;\n\t\tself.$arrows = [];\n\n\t\t//  Set our indexes and totals\n\t\tself.total = 0;\n\t\tself.current = 0;\n\n\t\t//  Generate a specific random ID so we don't dupe events\n\t\tself.prefix = self._ + '-';\n\t\tself.eventSuffix = '.' + self.prefix + ~~(Math.random() * 2e3);\n\n\t\t//  In case we're going to use the autoplay\n\t\tself.interval = null;\n\n\t\t//  Get everything set up innit\n\t\tself.init = function(options) {\n\t\t\t//  Set up our options inside here so we can re-init at\n\t\t\t//  any time\n\t\t\tself.options = $.extend({}, self.defaults, options);\n\n\t\t\t//  Our elements\n\t\t\tself.$container = self.$context.find(self.options.selectors.container).addClass(self.prefix + 'wrap');\n\t\t\tself.$slides = self.$container.children(self.options.selectors.slides);\n\n\t\t\t//  We'll manually init the container\n\t\t\tself.setup();\n\n\t\t\t//  We want to keep this script as small as possible\n\t\t\t//  so we'll optimise some checks\n\t\t\t$.each(['nav', 'arrows', 'keys', 'infinite'], function(index, module) {\n\t\t\t\tself.options[module] && self['init' + $._ucfirst(module)]();\n\t\t\t});\n\n\t\t\t//  Add swipe support\n\t\t\tif(jQuery.event.special.swipe && self.options.swipe) {\n\t\t\t\tself.initSwipe();\n\t\t\t}\n\n\t\t\t//  If autoplay is set to true, call self.start()\n\t\t\t//  to start calling our timeouts\n\t\t\tself.options.autoplay && self.start();\n\n\t\t\t//  We should be able to recalculate slides at will\n\t\t\tself.calculateSlides();\n\n\t\t\t//  Listen to a ready event\n\t\t\tself.$context.trigger(self._ + '.ready');\n\n\t\t\t//  Everyday I'm chainin'\n\t\t\treturn self.animate(self.options.index || self.current, 'init');\n\t\t};\n\n\t\tself.setup = function() {\n\t\t\t//  Add a CSS hook to the main element\n\t\t\tself.$context.addClass(self.prefix + self.options.animation).wrap('<div class=\"' + self._ + '\" />');\n\t\t\tself.$parent = self.$context.parent('.' + self._);\n\n\t\t\t//  We need to manually check if the container is absolutely\n\t\t\t//  or relatively positioned\n\t\t\tvar position = self.$context.css('position');\n\n\t\t\t//  If we don't already have a position set, we'll\n\t\t\t//  automatically set it ourselves\n\t\t\tif(position === 'static') {\n\t\t\t\tself.$context.css('position', 'relative');\n\t\t\t}\n\n\t\t\tself.$context.css('overflow', 'hidden');\n\t\t};\n\n\t\t//  Set up the slide widths to animate with\n\t\t//  so the box doesn't float over\n\t\tself.calculateSlides = function() {\n\t\t\t// update slides before recalculating the total\n\t\t\tself.$slides = self.$container.children(self.options.selectors.slides);\n\n\t\t\tself.total = self.$slides.length;\n\n\t\t\t//  Set the total width\n\t\t\tif(self.options.animation !== 'fade') {\n\t\t\t\tvar prop = 'width';\n\n\t\t\t\tif(self.options.animation === 'vertical') {\n\t\t\t\t\tprop = 'height';\n\t\t\t\t}\n\n\t\t\t\tself.$container.css(prop, (self.total * 100) + '%').addClass(self.prefix + 'carousel');\n\t\t\t\tself.$slides.css(prop, (100 / self.total) + '%');\n\t\t\t}\n\t\t};\n\n\n\t\t//  Start our autoplay\n\t\tself.start = function() {\n\t\t\tself.interval = setTimeout(function() {\n\t\t\t\t//  Move on to the next slide\n\t\t\t\tself.next();\n\n\t\t\t\t//  If we've got autoplay set up\n\t\t\t\t//  we don't need to keep starting\n\t\t\t\t//  the slider from within our timeout\n\t\t\t\t//  as .animate() calls it for us\n\t\t\t}, self.options.delay);\n\n\t\t\treturn self;\n\t\t};\n\n\t\t//  And pause our timeouts\n\t\t//  and force stop the slider if needed\n\t\tself.stop = function() {\n\t\t\tclearTimeout(self.interval);\n\n\t\t\treturn self;\n\t\t};\n\n\n\t\t//  Set up our navigation\n\t\tself.initNav = function() {\n\t\t\tvar $nav = $('<nav class=\"' + self.prefix + 'nav\"><ol /></nav>');\n\n\t\t\t//  Build our click navigation item-by-item\n\t\t\tself.$slides.each(function(key) {\n\t\t\t\t//  If we've already set a label, let's use that\n\t\t\t\t//  instead of generating one\n\t\t\t\tvar label = this.getAttribute('data-nav') || key + 1;\n\n\t\t\t\t//  Listen to any callback functions\n\t\t\t\tif($.isFunction(self.options.nav)) {\n\t\t\t\t\tlabel = self.options.nav.call(self.$slides.eq(key), key, label);\n\t\t\t\t}\n\n\t\t\t\t//  And add it to our navigation item\n\t\t\t\t$nav.children('ol').append('<li data-slide=\"' + key + '\">' + label + '</li>');\n\t\t\t});\n\n\t\t\t//  Keep a copy of the nav everywhere so we can use it\n\t\t\tself.$nav = $nav.insertAfter(self.$context);\n\n\t\t\t//  Now our nav is built, let's add it to the slider and bind\n\t\t\t//  for any click events on the generated links\n\t\t\tself.$nav.find('li').on('click' + self.eventSuffix, function() {\n\t\t\t\t//  Cache our link and set it to be active\n\t\t\t\tvar $me = $(this).addClass(self.options.activeClass);\n\n\t\t\t\t//  Set the right active class, remove any other ones\n\t\t\t\t$me.siblings().removeClass(self.options.activeClass);\n\n\t\t\t\t//  Move the slide\n\t\t\t\tself.animate($me.attr('data-slide'));\n\t\t\t});\n\t\t};\n\n\n\t\t//  Set up our left-right arrow navigation\n\t\t//  (Not keyboard arrows, prev/next buttons)\n\t\tself.initArrows = function() {\n\t\t\tif(self.options.arrows === true) {\n\t\t\t\tself.options.arrows = self.defaults.arrows;\n\t\t\t}\n\n\t\t\t//  Loop our options object and bind our events\n\t\t\t$.each(self.options.arrows, function(key, val) {\n\t\t\t\t//  Add our arrow HTML and bind it\n\t\t\t\tself.$arrows.push(\n\t\t\t\t\t$(val).insertAfter(self.$context).on('click' + self.eventSuffix, self[key])\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\n\t\t//  Set up our keyboad navigation\n\t\t//  Allow binding to multiple keycodes\n\t\tself.initKeys = function() {\n\t\t\tif(self.options.keys === true) {\n\t\t\t\tself.options.keys = self.defaults.keys;\n\t\t\t}\n\n\t\t\t$(document).on('keyup' + self.eventSuffix, function(e) {\n\t\t\t\t$.each(self.options.keys, function(key, val) {\n\t\t\t\t\tif(e.which === val) {\n\t\t\t\t\t\t$.isFunction(self[key]) && self[key].call(self);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\t//  Requires jQuery.event.swipe\n\t\t//  -> stephband.info/jquery.event.swipe\n\t\tself.initSwipe = function() {\n\t\t\tvar width = self.$slides.width();\n\n\t\t\t//  We don't want to have a tactile swipe in the slider\n\t\t\t//  in the fade animation, as it can cause some problems\n\t\t\t//  with layout, so we'll just disable it.\n\t\t\tif(self.options.animation !== 'fade') {\n\n\t\t\t\tself.$container.on({\n\n\t\t\t\t\tmovestart: function(e) {\n\t\t\t\t\t\t//  If the movestart heads off in a upwards or downwards\n\t\t\t\t\t\t//  direction, prevent it so that the browser scrolls normally.\n\t\t\t\t\t\tif((e.distX > e.distY && e.distX < -e.distY) || (e.distX < e.distY && e.distX > -e.distY)) {\n\t\t\t\t\t\t\treturn !!e.preventDefault();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tself.$container.css('position', 'relative');\n\t\t\t\t\t},\n\n\t\t\t\t\tmove: function(e) {\n\t\t\t\t\t\tself.$container.css('left', -(100 * self.current) + (100 * e.distX / width) + '%');\n\t\t\t\t\t},\n\n\t\t\t\t\tmoveend: function(e) {\n\t\t\t\t\t\t// Check if swiped distance is greater than threshold.\n\t\t\t\t\t\t// If yes slide to next/prev slide. If not animate to\n\t\t\t\t\t\t// starting point.\n\n\t\t\t\t\t\tif((Math.abs(e.distX) / width) > self.options.swipeThreshold) {\n\n\t\t\t\t\t\t\tself[e.distX < 0 ? 'next' : 'prev']();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\tself.$container.animate({left: -(100 * self.current) + '%' }, self.options.speed / 2 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t//  Infinite scrolling is a massive pain in the arse\n\t\t//  so we need to create a whole bloody function to set\n\t\t//  it up. Argh.\n\t\tself.initInfinite = function() {\n\t\t\tvar pos = ['first', 'last'];\n\n\t\t\t$.each(pos, function(index, item) {\n\t\t\t\tself.$slides.push.apply(\n\t\t\t\t\tself.$slides,\n\n\t\t\t\t\t//  Exclude all cloned slides and call .first() or .last()\n\t\t\t\t\t//  depending on what `item` is.\n\t\t\t\t\tself.$slides.filter(':not(\".' + self._ + '-clone\")')[item]()\n\n\t\t\t\t\t//  Make a copy of it and identify it as a clone\n\t\t\t\t\t.clone().addClass(self._ + '-clone')\n\n\t\t\t\t\t//  Either insert before or after depending on whether we're\n\t\t\t\t\t//  the first or last clone\n\t\t\t\t\t['insert' + (index === 0 ? 'After' : 'Before')](\n\t\t\t\t\t\t//  Return the other element in the position array\n\t\t\t\t\t\t//  if item = first, return \"last\"\n\t\t\t\t\t\tself.$slides[pos[~~!index]]()\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\t//  Remove any trace of arrows\n\t\t//  Loop our array of arrows and use jQuery to remove\n\t\t//  It'll unbind any event handlers for us\n\t\tself.destroyArrows = function() {\n\t\t\t$.each(self.$arrows, function(i, $arrow) {\n\t\t\t\t$arrow.remove();\n\t\t\t});\n\t\t};\n\n\t\t//  Remove any swipe events and reset the position\n\t\tself.destroySwipe = function() {\n\t\t\t//  We bind to 4 events, so we'll unbind those\n\t\t\tself.$container.off('movestart move moveend');\n\t\t};\n\n\t\t//  Unset the keyboard navigation\n\t\t//  Remove the handler\n\t\tself.destroyKeys = function() {\n\t\t\t//  Remove the event handler\n\t\t\t$(document).off('keyup' + self.eventSuffix);\n\t\t};\n\n\t\tself.setIndex = function(to) {\n\t\t\tif(to < 0) {\n\t\t\t\tto = self.total - 1;\n\t\t\t}\n\n\t\t\tself.current = Math.min(Math.max(0, to), self.total - 1);\n\n\t\t\tif(self.options.nav) {\n\t\t\t\tself.$nav.find('[data-slide=\"' + self.current + '\"]')._active(self.options.activeClass);\n\t\t\t}\n\n\t\t\tself.$slides.eq(self.current)._active(self.options.activeClass);\n\n\t\t\treturn self;\n\t\t};\n\n\t\t//  Despite the name, this doesn't do any animation - since there's\n\t\t//  now three different types of animation, we let this method delegate\n\t\t//  to the right type, keeping the name for backwards compat.\n\t\tself.animate = function(to, dir) {\n\t\t\t//  Animation shortcuts\n\t\t\t//  Instead of passing a number index, we can now\n\t\t\t//  use .data('unslider').animate('last');\n\t\t\t//  or .unslider('animate:last')\n\t\t\t//  to go to the very last slide\n\t\t\tif(to === 'first') to = 0;\n\t\t\tif(to === 'last') to = self.total;\n\n\t\t\t//  Don't animate if it's not a valid index\n\t\t\tif(isNaN(to)) {\n\t\t\t\treturn self;\n\t\t\t}\n\n\t\t\tif(self.options.autoplay) {\n\t\t\t\tself.stop().start();\n\t\t\t}\n\n\t\t\tself.setIndex(to);\n\n\t\t\t//  Add a callback method to do stuff with\n\t\t\tself.$context.trigger(self._ + '.change', [to, self.$slides.eq(to)]);\n\n\t\t\t//  Delegate the right method - everything's named consistently\n\t\t\t//  so we can assume it'll be called \"animate\" +\n\t\t\tvar fn = 'animate' + $._ucfirst(self.options.animation);\n\n\t\t\t//  Make sure it's a valid animation method, otherwise we'll get\n\t\t\t//  a load of bug reports that'll be really hard to report\n\t\t\tif($.isFunction(self[fn])) {\n\t\t\t\tself[fn](self.current, dir);\n\t\t\t}\n\n\t\t\treturn self;\n\t\t};\n\n\n\t\t//  Shortcuts for animating if we don't know what the current\n\t\t//  index is (i.e back/forward)\n\t\t//  For moving forward we need to make sure we don't overshoot.\n\t\tself.next = function() {\n\t\t\tvar target = self.current + 1;\n\n\t\t\t//  If we're at the end, we need to move back to the start\n\t\t\tif(target >= self.total) {\n\t\t\t\ttarget = 0;\n\t\t\t}\n\n\t\t\treturn self.animate(target, 'next');\n\t\t};\n\n\t\t//  Previous is a bit simpler, we can just decrease the index\n\t\t//  by one and check if it's over 0.\n\t\tself.prev = function() {\n\t\t\treturn self.animate(self.current - 1, 'prev');\n\t\t};\n\n\n\t\t//  Our default animation method, the old-school left-to-right\n\t\t//  horizontal animation\n\t\tself.animateHorizontal = function(to) {\n\t\t\tvar prop = 'left';\n\n\t\t\t//  Add RTL support, slide the slider\n\t\t\t//  the other way if the site is right-to-left\n\t\t\tif(self.$context.attr('dir') === 'rtl') {\n\t\t\t\tprop = 'right';\n\t\t\t}\n\n\t\t\tif(self.options.infinite) {\n\t\t\t\t//  So then we need to hide the first slide\n\t\t\t\tself.$container.css('margin-' + prop, '-100%');\n\t\t\t}\n\n\t\t\treturn self.slide(prop, to);\n\t\t};\n\n\t\t//  The same animation methods, but vertical support\n\t\t//  RTL doesn't affect the vertical direction so we\n\t\t//  can just call as is\n\t\tself.animateVertical = function(to) {\n\t\t\tself.options.animateHeight = true;\n\n\t\t\t//  Normal infinite CSS fix doesn't work for\n\t\t\t//  vertical animation so we need to manually set it\n\t\t\t//  with pixels. Ah well.\n\t\t\tif(self.options.infinite) {\n\t\t\t\tself.$container.css('margin-top', -self.$slides.outerHeight());\n\t\t\t}\n\n\t\t\treturn self.slide('top', to);\n\t\t};\n\n\t\t//  Actually move the slide now\n\t\t//  We have to pass a property to animate as there's\n\t\t//  a few different directions it can now move, but it's\n\t\t//  otherwise unchanged from before.\n\t\tself.slide = function(prop, to) {\n\t\t\t//  If we want to change the height of the slider\n\t\t\t//  to match the current slide, you can set\n\t\t\t//  {animateHeight: true}\n\t\t\tself.animateHeight(to);\n\n\t\t\t//  For infinite sliding we add a dummy slide at the end and start\n\t\t\t//  of each slider to give the appearance of being infinite\n\t\t\tif(self.options.infinite) {\n\t\t\t\tvar dummy;\n\n\t\t\t\t//  Going backwards to last slide\n\t\t\t\tif(to === self.total - 1) {\n\t\t\t\t\t//  We're setting a dummy position and an actual one\n\t\t\t\t\t//  the dummy is what the index looks like\n\t\t\t\t\t//  (and what we'll silently update to afterwards),\n\t\t\t\t\t//  and the actual is what makes it not go backwards\n\t\t\t\t\tdummy = self.total - 3;\n\t\t\t\t\tto = -1;\n\t\t\t\t}\n\n\t\t\t\t//  Going forwards to first slide\n\t\t\t\tif(to === self.total - 2) {\n\t\t\t\t\tdummy = 0;\n\t\t\t\t\tto = self.total - 2;\n\t\t\t\t}\n\n\t\t\t\t//  If it's a number we can safely set it\n\t\t\t\tif(typeof dummy === 'number') {\n\t\t\t\t\tself.setIndex(dummy);\n\n\t\t\t\t\t//  Listen for when the slide's finished transitioning so\n\t\t\t\t\t//  we can silently move it into the right place and clear\n\t\t\t\t\t//  this whole mess up.\n\t\t\t\t\tself.$context.on(self._ + '.moved', function() {\n\t\t\t\t\t\tif(self.current === dummy) {\n\t\t\t\t\t\t\tself.$container.css(prop, -(100 * dummy) + '%').off(self._ + '.moved');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//  We need to create an object to store our property in\n\t\t\t//  since we don't know what it'll be.\n\t\t\tvar obj = {};\n\n\t\t\t//  Manually create it here\n\t\t\tobj[prop] = -(100 * to) + '%';\n\n\t\t\t//  And animate using our newly-created object\n\t\t\treturn self._move(self.$container, obj);\n\t\t};\n\n\n\t\t//  Fade between slides rather than, uh, sliding it\n        self.animateFade = function(to) {\n\t\t\t//  If we want to change the height of the slider\n\t\t\t//  to match the current slide, you can set\n\t\t\t//  {animateHeight: true}\n\t\t\tself.animateHeight(to);\n\n\t\t\tvar $active = self.$slides.eq(to).addClass(self.options.activeClass);\n\n\t\t\t//  Toggle our classes\n\t\t\tself._move($active.siblings().removeClass(self.options.activeClass), {opacity: 0});\n\t\t\tself._move($active, {opacity: 1}, false);\n\t\t};\n\n\t\t// Animate height of slider\n\t\tself.animateHeight = function(to) {\n\t\t\t//  If we want to change the height of the slider\n\t\t\t//  to match the current slide, you can set\n\t\t\t//  {animateHeight: true}\n\t\t\tif (self.options.animateHeight) {\n\t\t\t\tself._move(self.$context, {height: self.$slides.eq(to).outerHeight()}, false);\n\t\t\t}\n\t\t};\n\n\t\tself._move = function($el, obj, callback, speed) {\n\t\t\tif(callback !== false) {\n\t\t\t\tcallback = function() {\n\t\t\t\t\tself.$context.trigger(self._ + '.moved');\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn $el._move(obj, speed || self.options.speed, self.options.easing, callback);\n\t\t};\n\n\t\t//  Allow daisy-chaining of methods\n\t\treturn self.init(options);\n\t};\n\n\t//  Internal (but global) jQuery methods\n\t//  They're both just helpful types of shorthand for\n\t//  anything that might take too long to write out or\n\t//  something that might be used more than once.\n\t$.fn._active = function(className) {\n\t\treturn this.addClass(className).siblings().removeClass(className);\n\t};\n\n\t//  The equivalent to PHP's ucfirst(). Take the first\n\t//  character of a string and make it uppercase.\n\t//  Simples.\n\t$._ucfirst = function(str) {\n\t\t//  Take our variable, run a regex on the first letter\n\t\treturn (str + '').toLowerCase().replace(/^./, function(match) {\n\t\t\t//  And uppercase it. Simples.\n\t\t\treturn match.toUpperCase();\n\t\t});\n\t};\n\n\t$.fn._move = function() {\n\t\tthis.stop(true, true);\n\t\treturn $.fn[$.fn.velocity ? 'velocity' : 'animate'].apply(this, arguments);\n\t};\n\n\t//  And set up our jQuery plugin\n\t$.fn.unslider = function(opts) {\n\t\treturn this.each(function() {\n\t\t\tvar $this = $(this);\n\n\t\t\t//  Allow usage of .unslider('function_name')\n\t\t\t//  as well as using .data('unslider') to access the\n\t\t\t//  main Unslider object\n\t\t\tif(typeof opts === 'string' && $this.data('unslider')) {\n\t\t\t\topts = opts.split(':');\n\n\t\t\t\tvar call = $this.data('unslider')[opts[0]];\n\n\t\t\t\t//  Do we have arguments to pass to the string-function?\n\t\t\t\tif($.isFunction(call)) {\n\t\t\t\t\treturn call.apply($this, opts[1] ? opts[1].split(',') : null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $this.data('unslider', new $.Unslider($this, opts));\n\t\t});\n\t};\n\n}));\n"],"sourceRoot":"assets/scripts/"}